// @generated
// rustfmt-format_generated_files: false
// This file was auto-generated by generate.py DO NOT MODIFY
use super::scalar;
use crate::AesBlockCipher;
use crate::SimdBase;
use crate::SimdBase32;
use crate::SimdBase4x;
use crate::SimdBase4x64;
use crate::SimdBase64;
use crate::SimdBase8;
use crate::SimdBase8x;
use proptest::prelude::*;
use std::ops::*;
proptest! { #[test] fn test_aes128_encrypt_only( block in any::<[u8; 16]>(), key in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128EncryptOnly::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128EncryptOnly::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes128_encrypt_only_convert( block in any::<[u8; 16]>(), key in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128EncryptOnly::from(Aes128::new_with_key(key)); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128EncryptOnly::from(Aes128::new_with_key(key)); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes128_encrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes128::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes128::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes_enc_only128_encrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes128EncryptOnly::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes128EncryptOnly::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes128_decrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes128::FIXED_KEY; aes.decrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes128::FIXED_KEY; aes.decrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes128_encrypt( block in any::<[u8; 16]>(), key in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes128_decrypt( block in any::<[u8; 16]>(), key in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128::new_with_key(key); aes.decrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x16 = key.into(); let aes = Aes128::new_with_key(key); aes.decrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn aes128encryptonly_encrypt_exact_hint( key in any::<[u8; 16]>(), blocks in any::<[ [u8; 16]; crate::Aes128EncryptOnly::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x16 = key.into(); let blocks: [U8x16; Aes128EncryptOnly::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes128EncryptOnly::new_with_key(key); let many = aes.encrypt_many(blocks); let single = blocks.array_map(|block| aes.encrypt(block)); prop_assert_eq!(many, single); } }
proptest! { #[test] fn aes128_encrypt_exact_hint( key in any::<[u8; 16]>(), blocks in any::<[ [u8; 16]; crate::Aes128::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x16 = key.into(); let blocks: [U8x16; Aes128::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes128::new_with_key(key); let many = aes.encrypt_many(blocks); let single = blocks.array_map(|block| aes.encrypt(block)); prop_assert_eq!(many, single); } }
proptest! { #[test] fn aes128_decrypt_exact_hint( key in any::<[u8; 16]>(), blocks in any::<[ [u8; 16]; crate::Aes128::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x16 = key.into(); let blocks: [U8x16; Aes128::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes128::new_with_key(key); let many = aes.decrypt_many(blocks); let single = blocks.array_map(|block| aes.decrypt(block)); prop_assert_eq!(many, single); } }
proptest! { #[test] fn test_aes256_encrypt_only( block in any::<[u8; 16]>(), key in any::<[u8; 32]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256EncryptOnly::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256EncryptOnly::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes256_encrypt_only_convert( block in any::<[u8; 16]>(), key in any::<[u8; 32]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256EncryptOnly::from(Aes256::new_with_key(key)); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256EncryptOnly::from(Aes256::new_with_key(key)); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes256_encrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes256::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes256::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes_enc_only256_encrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes256EncryptOnly::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes256EncryptOnly::FIXED_KEY; aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_fixed_aes256_decrypt( block in any::<[u8; 16]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let aes = Aes256::FIXED_KEY; aes.decrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let aes = Aes256::FIXED_KEY; aes.decrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes256_encrypt( block in any::<[u8; 16]>(), key in any::<[u8; 32]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256::new_with_key(key); aes.encrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn test_aes256_decrypt( block in any::<[u8; 16]>(), key in any::<[u8; 32]>(), ) { let scalar_out = { use scalar::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256::new_with_key(key); aes.decrypt_many([block])[0].as_array() }; let platform_out = { use crate::*; let block: U8x16 = block.into(); let key: U8x32 = key.into(); let aes = Aes256::new_with_key(key); aes.decrypt_many([block])[0].as_array() }; prop_assert_eq!(scalar_out, platform_out); } }
proptest! { #[test] fn aes256encryptonly_encrypt_exact_hint( key in any::<[u8; 32]>(), blocks in any::<[ [u8; 16]; crate::Aes256EncryptOnly::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x32 = key.into(); let blocks: [U8x16; Aes256EncryptOnly::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes256EncryptOnly::new_with_key(key); let many = aes.encrypt_many(blocks); let single = blocks.array_map(|block| aes.encrypt(block)); prop_assert_eq!(many, single); } }
proptest! { #[test] fn aes256_encrypt_exact_hint( key in any::<[u8; 32]>(), blocks in any::<[ [u8; 16]; crate::Aes256::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x32 = key.into(); let blocks: [U8x16; Aes256::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes256::new_with_key(key); let many = aes.encrypt_many(blocks); let single = blocks.array_map(|block| aes.encrypt(block)); prop_assert_eq!(many, single); } }
proptest! { #[test] fn aes256_decrypt_exact_hint( key in any::<[u8; 32]>(), blocks in any::<[ [u8; 16]; crate::Aes256::BLOCK_COUNT_HINT ]>(), ) { use crate::*; use crate::array_utils::*; let key: U8x32 = key.into(); let blocks: [U8x16; Aes256::BLOCK_COUNT_HINT] = bytemuck::cast(blocks); let aes = Aes256::new_with_key(key); let many = aes.decrypt_many(blocks); let single = blocks.array_map(|block| aes.decrypt(block)); prop_assert_eq!(many, single); } }
